\section{Spécifications}
L'objet principal de notre programme est de modéliser la chute d'un solide dans un
fluide, tout en prenant en compte son interaction avec un environnement solide (chocs).

\subsection{IHM - \emph{Interface Homme - Machine}}
Il est proposé à l'utilisateur de dessiner à la fois le décor et l'objet.
Les deux dessins sont séparés en deux fenêtres, munie chacunes de leur interface propre,
puisque les outils nécessaires au dessin du décor ne sont pas les mêmes que pour le dessin de l'objet.
L'utilisateur peut également ouvrir une fenêtre dédiée aux paramètres physiques, afin d'influer
sur la valeur de la gravité notamment.

\subsection{Problèmes physiques et méthodes de résolution}
\subsubsection{Forces}
Le programme doit prendre en compte les différentes forces appliquées à 
un instant $t$ sur le solide. Le mouvement de ce solide est donc déterminé
par les équations de la mécanique newtonienne.
On peut donc définir les différentes forces appliquées sur le solide :

\begin{itemize}
\item[$\bullet$] La gravité : \dotfill{} $\overrightarrow{P} = mg\, \overrightarrow{y_0}$ 
\item[$\bullet$] La poussée d'Archimède : \dotfill{} $\overrightarrow{F_{Ar}} = -\rho_{liquide}\cdot V_{deplace} \, \overrightarrow{y_0} $
\item[$\bullet$] Les frottements lors du contact: \dotfill{}$\overrightarrow{F_{fr}} = -f \,\overrightarrow{V}_{\text{Objet/Décor}}$
\end{itemize}

La majorité des forces sont résolues à l'aide d'algorithmes basiques de
calcul, prenant en compte des paramètres telles que le volume de l'objet,
sa vitesse ou son poids.
\subsubsection{\emph{PFD} - Principe Fondamental de la Dynamique }
Dans le cas d'un problème plan, notre problème s'exprime sous la forme :
\begin{equation}
\sum F_x = m \frac {dv_x}{dt} \: \text{et} \: \sum F_y = m\frac{dv_y}{dt} \: \text{et} \: \sum M_z = J \frac {d\omega}{dt}
\end{equation}
En supposant le $\Delta t$ du timer suffisament faible, on peut assimiler
$\frac {dv_x}{dt}$ à $\frac{\Delta v_x}{\Delta t}$,
$ \frac {dv_y}{dt} \approx \frac{\Delta v_y}{\Delta t}$ et
$ \frac{d\omega}{dt} \approx \frac{\Delta \omega}{\Delta t}$ .
\newline
Avec les mêmes approximations, on obtient :
$\frac {dx}{dt} = v_x \approx \frac{\Delta x}{\Delta t}$, 
$ \frac {dy}{dt} \approx \frac{\Delta y}{\Delta t}$ et
$ \frac{d\theta}{dt} \approx \frac{\Delta \theta}{\Delta t}$. \\
La vitesse initiale $\overrightarrow{v_0}$ est définie par l'utilisateur.
Ainsi, connaissant la vitesse $\overrightarrow{v(t)}$ à un instant $t$,
on peut calculer la vitesse $\overrightarrow{v(t+\Delta t)}$ à l'instant $t + \Delta t$.

\begin{equation}
v_{x}(t+\Delta t)= v_{x}(t) + m \Delta t \sum F_x \: \text{et}\:
v_{y}(t+\Delta t)= v_{y}(t) + m\Delta t\sum F_y \: \text{et}\:
\omega (t + \Delta t)= \omega(t) + J\Delta t \sum m_z 
\end{equation}
En prenant en compte les approximations précédentes, on obtient le système suivant :
\begin{equation}
x(t+\Delta t) = x(t) +\Delta t \cdot v_{x}(t) \: \text{et} \:
y(t+\Delta t) = x(t) +\Delta t \cdot v_{x}(t) \: \text{et} \:
\theta (t+\Delta t) = \theta (t) + \Delta t \cdot \omega (t) \: \text \:
\end{equation}

\newpage
\subsubsection{Collisions}
Notons $\overrightarrow{v_c}$ la vitesse du point de contact et $\overrightarrow{v_g}$
la vitesse, connue, du centre de gravité du solide.
Pour le calcul de la nouvelle vitesse du solide, nous supposons que le contact
entre le solide et le décor lors du choc est ponctuel. 
On se place dans la base de contact définie par le schéma suivant :

\begin{center}
\begin{figure}[h]
\begin{center}
\scalebox{0.2}[0.2]{\includegraphics*{../images/collision.png}}
\end{center}
\caption{Base locale du contact}
\end{figure}
\end{center}
Le contact étant ponctuel, on suppose que les forces appliquées au point
de contact C sont similaires à celles appliquées dans le modèle de choc d'une particule, on a donc :
\begin{equation}
v_{C,x,initial} = v_{C,x,final} \: \text{et} \: v_{C,y,initial} = -v_{C,y,final}
\end{equation}
Or, en notant $x_G$ et $y_G$ les coordonnées du centre de gravité dans 
la base de contact :
\begin{equation}
v_{C,x}=v_{G,x}+y_G \cdot \omega \: \text{et} \: v_{C,y} = v_{g,y} -x_G\cdot \omega
\end{equation}
On suppose dans un premier temps que l'énergie cinétique est conservée :
\begin{equation}
J\omega^2_{initial} + m(v^2_{g,x,initial} + v^2_{g,y,initial} )
=
J\omega^2_{final} + m(v^2_{g,x,final} + v^2_{g,y,final} )
\end{equation}
On obtient ainsi un système de 3 équations qui nous donne les équations de
mouvement après collision.
$(v_{x0} \: , \: v_{x1})$ désigne $(v_{G,x,initial} \: , \: v_{G,y,initial})$,
de même pour $y$ et $\omega$ .\\
On obtient ainsi les solutions suivantes :
\begin{equation}
\omega_1 = \frac{-m(x^2_G+v_{x0}y_G+y^2_G\omega_0 + v_{y0}) +\sqrt{\Delta}}{my^2_G + mx^2_G +J}
\end{equation}

\begin{eqnarray*}
	\Delta & = & \omega^2 J^2 -2Jmv_{x0}y_G\omega_0 + 2Jmv_{y0}x_G \omega_0  + 2m^2v_{x0}y_Gv_{y0}x_G - 4m^2v_{x0}y_Gx^2_G\omega_0 \\
		& & +\ 4m^2y^2_g\omega_0 v_{y0} x_G- 4m^2y^2_g\omega^2_0x^2_g + m^2v^2_{x0}y^2_G + m^2v^2_{y0}x^2_G
\end{eqnarray*}

On obtient ainsi :
\begin{equation}
v_{x1}=v_{x0} +y_G(\omega_0 - \omega_1) \: \ \text{et} \ \:  v_{y1}=v_{y0} +x_G(\omega_0 - \omega_1)
\end{equation} 

\newpage

\section{Réalisation}
\subsection{Interface}
La fenêtre principale affiche un menu utilisateur, une fenêtre de dessin,
et un espace d'affichage des principaux paramètres physiques.
Outre ces fonctionnalités, c'est également à elle d'effectuer l'animation
de l'image, en calculant régulièrement (présence d'un Timer) la position
du solide ainsi que sa vitesse et son interaction avec le décor.
Les autres fenêtres ont pour mission de gérer le dessin de l'objet et son remplissage,
le dessin du décor et la gestion des matériaux.


\subsection{Gestion des chocs}
La partie la plus compliquée dans la gestion des chocs reste la détection des chocs
et le calcul de la tangente locale au décor. Afin d'obtenir ces informations,
notre algorithme analyse à chaque itération d'un timer prédéfini
les pixels autour du solide, et si jamais ceux ci appartiennent à un des
matériaux (tri par couleur), on calcule la tangente locale à l'aide de
tous les points de contact. Ceci nous permet de déterminer la direction 
de rebond du solide, ainsi que d'appliquer les forces de frottement propres au matériau.


\subsection{Remplissage de l'objet}
Un des problèmes majeurs qui nous fut posé durant ce projet fut le remplissage
du solide afin de pouvoir déterminer sa masse et son centre d'inertie.
Tout d'abord, il fallut s'assurer que le dessin de l'utilisateur était bien connexe.
Pour remédier à ce problème, nous traçons une droite entre le point de départ
$(X_e,Y_e)$ et le point de sortie $(X_s,Y_s)$.
Nous avons choisi la méthode du ScanLine-FloodFill pour remplir le solide dessiné.
Cette méthode utilise une graine (la \emph{seed}) placée sur un point quelquonque
de notre solide, et analyse tout les pixels environnants pour déterminer
quels sont ceux à l'intérieur du solide, et les autres.
Après plusieurs essais infructueux avec un algorithme classique, nous avons
adapté un algorithme en C trouvé sur Internet, qui analyse ligne par ligne l'objet,
permettant ainsi un gain considérable en efficacité. 
%
%\begin{algorithm}[h]
%\caption{Pseudo algorithme de remplissage par ligne}
%\begin{algorithmic}
%	\STATE Prout;
%	\PROCEDURE {RemplirLigne} {$(aOldColor,aNewColor, X_{seed}, Y_{seed})$}
%		\WHILE{$couleur(Y+1) = aOldColor$ and $couleur(Y+1) \neq couleur_{\text{frontière}}$}
%			\STATE $couleur(Y+1) \gets aNewColor$
%		\ENDWHILE
%		\IF{$couleur_{voisin\_ gauche} = aOldColor$}
%			\STATE remplir\_ Ligne(X-1,Y)
%		\ENDIF
%		\IF{$couleur_{voisin\_ droit} = aOldColor$}
%			\STATE remplir\_ Ligne(X+1,Y)
%		\ENDIF
%	\ENDPROCEDURE
%\end{algorithmic}
%\end{algorithm}
%\begin{algorithmic}[1]
%\repeat
%\Comment{forever}
%\State this\Until{you die.}
%\end{algorithmic}

\newpage

\section{Bugs - Améliorations}
Il subsiste de nombreux bugs et améliorations possibles de notre projet.
En particulier, de nombreuses améliorations que nous pensions apporter
à notre projet n'ont pas été implémentées par faute de temps, certains 
problèmes ayant été plus chronophages que prévu.
\subsection{Améliorations}
\begin{itemize}
\item[$\bullet$] Différents fluides (air, eau, vide \dots)
\item[$\bullet$] Variation aléatoire et incidence du vent 
\item[$\bullet$] Amélioration du modèle physique (élasticité \dots )
\item[$\bullet$] Modification du décor et de l'objet en temps réel par l'utilisateur
\item[$\bullet$] Tracé de la trajectoire de l'objet
\item[$\bullet$] Force de frottement prenant en compte la forme de l'objet
\end{itemize}
\subsection{Bugs}
\begin{itemize}
\item[$\bullet$] Lenteur de l'exécution sous Linux (pas de problèmes sous Windows)
\item[$\bullet$] Le décor ne se remet pas à jour si on le redessine
\item[$\bullet$] Calcul des tangentes peu précis (sinon il serait beaucoup trop lent)
\item[$\bullet$] Mauvais fonctionnement sur certains ordinateurs (64 bits?)
\end{itemize}
